{"version":3,"sources":["meteor://ðŸ’»app/packages/ethereum_blocks/blocks.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sH","file":"/packages/ethereum_blocks.js","sourcesContent":["/**\n\n@module Ethereum:blocks\n*/\n\n\n\n/**\nThe EthBlocks collection, with some ethereum additions.\n\n@class EthBlocks\n@constructor\n*/\n\n\n\nEthBlocks = new Mongo.Collection('ethereum_blocks', {connection: null});\n\n// if(typeof PersistentMinimongo !== 'undefined')\n//     new PersistentMinimongo(EthBlocks);\n\n\n/**\nGives you reactively the lates block.\n\n@property latest\n*/\nObject.defineProperty(EthBlocks, 'latest', {\n    get: function () {\n        return EthBlocks.findOne({}, {sort: {number: -1}}) || {};\n    },\n    set: function (values) {\n        var block = EthBlocks.findOne({}, {sort: {number: -1}}) || {};\n        values = values || {};\n        EthBlocks.update(block._id, {$set: values});\n    }\n});\n\n/**\nStores all the callbacks\n\n@property _forkCallbacks\n*/\nEthBlocks._forkCallbacks = [];\n\n\n/**\nStart looking for new blocks\n\n@method init\n*/\nEthBlocks.init = function(){\n\n    if(typeof web3 === 'undefined') {\n        console.warn('EthBlocks couldn\\'t find web3, please make sure to instantiate a web3 object before calling EthBlocks.init()');\n        return;\n    }\n\n    Tracker.nonreactive(function() {\n        observeLatestBlocks();\n    });\n};\n\n/**\nAdd callbacks to detect forks\n\n@method detectFork\n*/\nEthBlocks.detectFork = function(cb){\n    EthBlocks._forkCallbacks.push(cb);\n};\n\n/**\nClear all blocks\n\n@method clear\n*/\nEthBlocks.clear = function(){\n    _.each(EthBlocks.find({}).fetch(), function(block){\n        EthBlocks.remove(block._id);\n    });\n};\n\n\n/**\nThe global block filter instance.\n\n@property filter\n*/\nvar filter = null;\n\n/**\nUpdate the block info and adds additional properties.\n\n@method updateBlock\n@param {Object} block\n*/\nfunction updateBlock(block){\n\n    // reset the chain, if the current blocknumber is 100 blocks less \n    if(block.number + 10 < EthBlocks.latest.number)\n        EthBlocks.clear();\n\n    block.difficulty = block.difficulty.toString(10);\n    block.totalDifficulty = block.totalDifficulty.toString(10);\n\n    web3.eth.getGasPrice(function(e, gasPrice){\n        if(!e) {\n            block.gasPrice = gasPrice.toString(10);\n            EthBlocks.upsert('bl_'+ block.hash.replace('0x','').substr(0,20), block);\n        }\n    });\n};\n\n/**\nObserve the latest blocks and store them in the Blocks collection.\nAdditionally cap the collection to 50 blocks\n\n@method observeLatestBlocks\n*/\nfunction observeLatestBlocks(){\n\n    // get the latest block immediately\n    web3.eth.getBlock('latest', function(e, block){\n        if(!e) {\n            updateBlock(block);\n        }\n    });\n\n    // GET the latest blockchain information\n    filter = web3.eth.filter('latest').watch(checkLatestBlocks);\n\n};\n\n/**\nThe observeLatestBlocks callback used in the block filter.\n\n@method checkLatestBlocks\n*/\nvar checkLatestBlocks = function(e, hash){\n    if(!e) {\n        web3.eth.getBlock(hash, function(e, block){\n            if(!e) {\n                var oldBlock = EthBlocks.latest;\n\n                // console.log('BLOCK', block.number);\n\n                // if(!oldBlock)\n                //     console.log('No previous block found: '+ --block.number);\n\n                // CHECK for FORK\n                if(oldBlock && oldBlock.hash !== block.parentHash) {\n                    // console.log('FORK detected from Block #'+ oldBlock.number + ' -> #'+ block.number +'!');\n\n                    _.each(EthBlocks._forkCallbacks, function(cb){\n                        if(_.isFunction(cb))\n                            cb(oldBlock, block);\n                    });\n                }\n\n                updateBlock(block);\n\n                // drop the 50th block\n                var blocks = EthBlocks.find({}, {sort: {number: -1}}).fetch();\n                if(blocks.length >= 5) {\n                    var count = 0;\n                    _.each(blocks, function(bl){\n                        count++;\n                        if(count >= 5)\n                            EthBlocks.remove({_id: bl._id});\n                    });\n                }\n            }\n        });\n\n    // try to re-create the filter on error\n    // TODO: want to do this?\n    } else {\n        filter.stopWatching();\n        filter = web3.eth.filter('latest').watch(checkLatestBlocks);\n    }\n};"]}