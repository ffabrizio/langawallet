{"version":3,"sources":["meteor://ðŸ’»app/packages/frozeman_persistent-minimongo/persistent-minimongo.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0G","file":"/packages/frozeman_persistent-minimongo.js","sourcesContent":["/**\nPackages\n\n@module Packages\n*/\n\n/**\nThe PersistentMinimongo package\n\n@class PersistentMinimongo\n@constructor\n*/\n\n\n\n/**\nIf the localstorage goes over 4.8 MB, trim the collections.\n\n@property capLocalStorageSize\n*/\nvar capLocalStorageSize = 4.8;\n\n/**\nIf the localstorage goes over `capLocalStorageSize`, trim the current collection,\nwhich wanted to add a new entry, by 50 entries.\n\n@property trimCollectionBy\n*/\nvar trimCollectionBy = 50;\n\n\nPersistentMinimongo = function (collection) {\n    var self = this;\n    if (! (self instanceof PersistentMinimongo))\n        throw new Error('use \"new\" to construct a PersistentMinimongo');\n\n    self.key = 'minimongo__' + collection._name;\n    self.col = collection;\n    self.stats = { added: 0, removed: 0, changed: 0 };\n\n    persisters.push(self);\n\n    // Check if the localstorage is to big and reduce the current collection by 50 items, every 30s\n    Meteor.setInterval(function() {\n        self.capCollection();\n    }, 1000 * 30);\n\n    // load from storage\n    self.refresh(true);\n\n    // Meteor.startup(function () {\n    self.col.find({}).observe({\n        added: function (doc) {\n\n            // get or initialize tracking list\n            var list = amplify.store(self.key);\n            if (! list)\n                list = [];\n\n            // add document id to tracking list and store\n            if (! _.contains(list, doc._id)) {\n                list.push(doc._id);\n                amplify.store(self.key, list);\n            }\n\n            // store copy of document into local storage, if not already there\n            var key = self._makeDataKey(doc._id);\n            if(! amplify.store(key)) {\n                amplify.store(key, doc);\n            }\n\n            ++self.stats.added;\n        },\n\n        removed: function (doc) {\n            var list = amplify.store(self.key);\n\n            // if not in list, nothing to do\n            if(! _.contains(list, doc._id))\n                return;\n\n            // remove from list\n            list = _.without(list, doc._id);\n\n            // remove document copy from local storage\n            amplify.store(self._makeDataKey(doc._id), null);\n\n            // if tracking list is empty, delete; else store updated copy\n            amplify.store(self.key, list.length === 0 ? null : list);\n\n            ++self.stats.removed;\n        },\n\n        changed: function (newDoc, oldDoc) {\n            // update document in local storage\n            amplify.store(self._makeDataKey(newDoc._id), newDoc);\n            ++self.stats.changed;\n        }\n    });\n    // });\n};\n\nPersistentMinimongo.prototype = {\n    constructor: PersistentMinimongo,\n    _getStats: function () {\n        return this.stats;\n    },\n    _getKey: function () {\n        return this.key;\n    },\n    _makeDataKey: function (id) {\n        return this.key + '__' + id;\n    },\n    /**\n    Refresh the local storage\n    \n    @method refresh\n    @return {String}\n    */\n    refresh: function (init) {\n        var self = this;\n        var list = amplify.store(self.key);\n\n        self.stats.added = 0;\n\n\n        if (!! list) {\n            var length = list.length;\n            list = _.filter(list, function (id) {\n                var doc = amplify.store(self._makeDataKey(id));\n                if(!! doc) {\n                    var id = doc._id;\n                    delete doc._id;\n                    self.col.upsert({_id: id}, {$set: doc});\n                }\n\n                return !! doc;\n            });\n\n            // if not initializing, check for deletes\n            if(! init) {\n                _.each(self.col.find({}).fetch(), function (doc) {\n                    if(! _.contains(list, doc._id))\n                        self.col.remove({ _id: doc._id});\n                });\n            }\n\n            // if initializing, save cleaned list (if changed)\n            if(init && length != list.length)\n                amplify.store(self.key, list.length === 0 ? null : list);\n        }\n    },\n    /**\n    Gets the current localstorage size in MB\n    \n    @method localStorageSize\n    @return {String} total localstorage size in MB\n    */\n    localStorageSize: function() {\n\n        // function toSizeMB(info) {\n        //   info.size = toMB(info.size).toFixed(2) + ' MB';\n        //   return info;\n        // }\n\n        // var sizes = Object.keys(localStorage).map(toSize).map(toSizeMB);\n        // console.table(sizes);\n\n        var size = 0;\n        if(localStorage) {\n            _.each(Object.keys(localStorage), function(key){\n                size += localStorage[key].length * 2 / 1024 / 1024;\n            });\n        }\n\n        return size;\n    },\n    /**\n    Check if the localstorage is to big and reduce the current collection by 50 items\n    \n    @method localStorageSize\n    @return {String}\n    */\n    capCollection: function(){\n        var _this = this;\n\n        if(_this.localStorageSize() > capLocalStorageSize) {\n            console.log(_this.localStorageSize(), _this.col.find({}).count());\n            // find the first 50 entries and remove them\n            _.each(_this.col.find({}, {limit: trimCollectionBy}).fetch(), function(item){\n                _this.col.remove(item._id);\n            });\n        }\n    }\n};\n\nvar persisters = [];\nvar lpTimer = null;\n\n// React on manual local storage changes\nMeteor.startup(function () {\n    $(window).bind('storage', function (e) {\n        Meteor.clearTimeout(lpTimer);\n        lpTimer = Meteor.setTimeout(function () {\n            _.each(persisters, function (lp) {\n                lp.refresh(false);\n            });\n        }, 250);\n    });\n});\n"]}